# 심화 프로그래밍 2024
부경대학교 2024 IoT 개발자 과정 심화 프로그래밍 언어 학습 리포지토리

## 1일차
- 개발환경 설치
	- Visual Studio 2022 Community 설치
	- C, C++ 소스코드 실행
-----
## 2일차(2024.02.21)
- C++ 기초
	- 기본개념
		- 함수 정의 : 사용할 함수를 정의하는 것
		- 함수 호출 : 함수정의에서 정의한 함수를 사용하기 위해 호출하는 것
		- 변수 선언 : RAM으로부터 저장 할 수 있는 공간을 할당받는 것
		- 전역 변수 : 프로그램의 시작과 동시에 메모리를 할당받음, 선언되어진 범위 안에서만 사용이 가능(static 영역에 저장)
		- 지역 변수 : 변수가 소속된 함수가 시작되어야만 메모리를 할당받음, func함수에서만 사용 가능, 프로그램 영역 어디에서든지 사용가능
		
	- 제어문(control flow statements) : 프로그램의 흐름을 제어하는 경우에 사용하는 실행문
		- 선택 제어문 : if, switch
		- 반복 제어문 : for, while
		
	- 자료형
		- 문자 : 문자, 문자열
		- 숫자 : 정수(int), 실수(float)
	
	- 오버로딩과 오버라이딩
		- 오버로딩(Overloading) : 함수의 이름이 같고, 매개변수의 개수나 타입이 달리하여 다른 함수를 사용하는 것(다중정의)
		- 오버라이딩(OverRiding) : 상속관계에서 발생, 상위 클래스의 함수를 하위 클래스에서 '재정의'하는 것
-----			
## 3일차
- C++ 기초
	- class 안에 들어 가는 함수 = Method

	- Default Value
	- Reference 함수
		- 반환형 Reference Type
	- Name Space		
	- 전역,지역변수
	- C에서 메모리
		- 스택 : 지역변수, 매개변수
		- HEAP : 사용자에게 할당된 영역
			= Malloc() -> free()반환 = 사용을 할려면 Malloc으로 할당을 받는다
		- data: 함수, 전역변수, 상수, 문자 리터럴
			
	- // A & B = 비트 And 연산자
	- // A && B = 논리 And 연산자 = 논리 곱
-----	
## 4일차(2024.02.23)

- C에서 메모리
	- 스택 : 지역변수 , 매개변수
	- heap : 사용자에게 할당된 영역, 사용하려면 malloc()(C++:new)으로 할당을 받는다. free()(C++:delete)로 반환
	- data : 함수, 전역변수, 상수, 문자리터럴
	
- 헤더파일 : C에 있는 헤더파일을 가져오려면 기존 헤더명에 c를 붙이고 확장자는 생략
	- stdio.h -> cstudio
	- stdlib.h -> cstdlib
	- math.h -> cmath
	
- 구조체(Struct) : 하나 이상의 변수를 묶어서 새로운 자료형을 정의하는 도구, 개발자가 만든 사용자 정의 자료형
	- C 타입 구조체 : 멤버 변수만 보유
	- C++ 타입 구조체 : 멤버 변수와 멤버 함수를 보유
	
- 클래스(Class)
	- 멤버 변수와 멤버 함수로 구성됨
	- 클래스 내부에는 멤버들의 선언으로 작성
	- 멤버함수의 정의를 외부로 빼서 사용할 수 있음(스코프연산자 사용, JAVA에선 불가능)
	- 접근제어 지시자
		- public : 어디서든 접근허용(주로 멤버함수(속성값))
		- protected : 상속관계에 놓여있을 때. 유도 클래스에서의 접근허용
		- private : 클래스 내(클래스 내에 정의도니 함수) 에서만 접근허용(주로 멤버변수)
-----
## 5일차(2024.02.26)
- 클래스(Class)
	- 정보은닉(Information Hiding)
		- 멤버변수를 private으로 선언하고, 해당 변수에 접근하는 함수를 별도로 정의해서, 안전한 형태로 멤버변수의 접근을 유도하는 것 -> 좋은 클래스가 되기 위한 기본조건!!
		- 엑세스 함수(access function) : private으로 선언된 멤버변수를 클래스 외부에서 접근하기 위해 정의되는 함수

	- const
		- 변수를 상수화 시키는 키워드
		- 함수 뒤에 const 선언이 추가되어 있을 경우, 이 함수 내에서는 멤버변수에 저장된 값을 변경하지 않겠다는 뜻 -> 멤버변수의 값을 변경하는 코드가 삽입되면 컴파일 에러가 발생
		- 함수 앞에 const 선언이 추가되어 있을 경우, 함수의 출력값을 상수화

	- 캡슐화(Encapsulation)
		- 클래스 안에 서로 연관있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하는 것

	- 생성자(Constructor)
		- 객체의 생성과 동시에 자동으로 호출되는 멤버 함수로 멤버변수들의 초기화를 담당
		- SimpleCalss sc(20) -> SimpleClass라는 Class의 생성자를 호출하는 함수, 20의 값을 넣고 객체명은 sc가 된다.
		- 클래스의 이름과 함수의 이름이 동일함
		- 반환형이 선언되어 있지 않으며, 실제로 반환하지 않음
		- 객체 생성시 딱 한번 호출됨
		- new 연산자를 이용한 객체 생성에도 생성자가 호출됨(malloc함수로는 생성자가 호출되지 않음)
		- 오버로딩이 가능함
		
	- 디폴트 생성자(Default Constructor) 
		- 매개변수(입력)를 가지지 않는 생성자
		- 모든 클래스는 디폴트 생성자를 가지고 있다
		- 별도의 생성자를 명시적으로 구현하지 않을 경우 default 생성자가 자동으로 만들어짐
		- 별도의 생성자를 명시적으로 구현해 놓은 경우 매개변수가 없는 default 생성자는 만들어지지 않음(필요한 경우 따로 구현해야함)

	- 멤버 이니셜라이저(Member Initializer)
		- 객체 생성시 초기화되지 않는 멤버들을 객체가 생성되기 전에(생성자가 실행되기 전에, 중괄호의 내용이 실행되기 전에) 초기화 할 때 사용(C++에만 존재)
		- 객체 생성 전에 선언과 동시에 초기화가 필요한 경우에 사용가능
		- !!!const형태의 변수선언과 참조형태의 변수 선언에서의 초기화에 사용!!!
		- 객체 생성과 상관없이 미리 초기화가 되는 멤버들을 초기화
		- 파일 분할을 할 경우, 함수의 정의 부분에 입력
		- 예시 : ID(sID), human(ahuman), age(hage)
-----
## 6일차(2024.02.27)
- 클래스(Class)
	- Private 생성자
		- private 생성자는 싱글톤 패턴의 구현 시 사용
		- 외부에서 직접적으로 사용 불가능
		
	- 소멸자(Destructor)
		- 클래스 이름 앞에 '~' 가 붙은 형태
		- 반환형이 선언되어 있지 않으며, 실제로 반환하지 않음
		- 매개변수는 void형으로 선언되어야 하기 떄문에 오버로딩도, 디폴트 값 설정도 불가능
		
	- 포인터(Pointer)
		- 객체 포인터 배열 : 객체의 주소 값 저장이 가능한 포인터 변수로 이뤄진 배열
		- this 포인터
			- 객체 자기자신을 가리키는 용도로 사용하는 포인터 -> 객체 자기자신의 주소값
			- 멤버 이니셜라이저에서는 this 포인터를 사용할 수 없음
			- this:객체 자기자신의 주소값, *this:객체 자기자신, return *this: 객체 자기자신을 리턴
		- 애로우 연산자(Arrow Operator) : 객체가 포인터일 때 그 멤버에 접근할 때 사용하는 연산자(예시: ptr1->ShowSimpleData(), this->num1)
		
- 복사 생성자(Copy Constructor)
	- 객체를 복사할 때 호출되는 생성자
	- 객체간 멤버 대 멤버 복사가 발생
	- 생성자의 오버로딩
	- 복사할 객체를 입력으로 가져야하는데 이때 원본 객체의 참조를 입력으로 받아야함 -> 객체 선언형태로 받을 경우, 호출과 매개변수 입력 과정에서 복사생성자가 무한반복됨
	- 디폴트 복사 생성자 : 복사생성자를 명시적으로 구현하지 않아도 자동으로 호출되는 복사 생성자
-----
## 7일차(2024.02.28)
- 복사 생성자(Copy Constructor)
	- 얕은 복사 
		- 디폴트 복사 생성자 사용시 발생.
		- 멤버 대 멤버의 단순 복사를 진행 -> 하나의 문자열을 두 개의 객체가 동시에 참조
		
	- 깊은 복사
		- 멤버 뿐만 아니라 포인터로 참조하는 대상까지도 깊게 복사한다는 뜻
		- 객체 별로 각각 문자열을 참조, 복사 대상이었던 기존 객체가 소멸하더라도 남아있는 객체가 참조하는 문자열이 그대로 남아있음
		
	- 복사 생성저가 호출되는 경우
		- 기존에 생성된 객체를 이용해서 새로운 객체를 초기화하는 경우
		- Call-by-value 방식의 함수호출 과정에서 객체를 인자로 전달하는 경우(Call-by-value : 함수가 인수로 전달받은 값을 복사하여 처리하는 방식)
		- 객체를 반환하되, 참조형으로 반환하지 않는 경우
		
	- 임시객체 :  실행 도중에 잠깐만 사용되는 객체로, 소스 코드에도 없는 힙 이외의 공간에 생성되는 것
		- 일반적으로 임시객체는 참조가 불가능하지만 const 키워드를 붙여서 상수화시키면(메모리에 할당됨) 참조가 가능해짐(예시 : Const Temporary & ref = Temporary(300);)
		- lvalue(좌변값)이 될 수 없음
		- 임시객체는 다음 행으로 넘어가면, 바로 소멸됨. 그러나 참조자에 참조되는 임시객체는, 바로 소멸되지 않음.
		
- friend와 static 그리고 const
	- const 선언
		- 객체의 const선언은 해당 객체의 데이터 변경을 허용하지 않겠다는 의미
		- const객체에서는 멤버 변수에 저장된 값을 수정하지 않는 const 함수만 호출 가능
		- const객체에서는 데이터를 변경하지 않는 함수라 할지라도 const 함수가 아니라면 호출 불가능
		- const 키워드에 따라서 함수 오버로드도 가능
		
	- friend 선언
		- 다른 클래스가 자신의 private 멤버에 직접 접근하는 것을 허용하는 선언
		- friend선언은 클래스 내에 public이나 private 상관없이 어디든 위치가능
	
	- static(정적변수)
		- 지역변수와 전역변수의 특징을 가지고 있음
		- 사용과 접근은 지역변수처럼 선언되어져있는 영역에서만 가능하지만, 할당받은 메모리 영역은 전역변수처럼 생성된 이후 프로그램의 수명 내내 지속된다.
-----
## 8일차(2024.02.29)
- friend와 static 그리고 const
	- static 변수
		- static 변수(->클래스 변수) : 일반적인 클래스의 멤버변수와는 달리 객체 없이 클래스 만으로도 접근이 가능한 변수. 클래스명으로 접근이 가능(예시:SoSimple::simObjCnt)
		- 하나만 생성하고 전역에서 공유하기 때문에 클래스 밖에서 초기화해야함 -> 생성자에서 초기화 할 경우, 객체가 생성될 때 마다 초기화됨
		- static 멤버함수
			- 선언된 클래스의 모든 객체가 공유
			- public으로 선언되면 클래스의 이름을 이용해서 호출이 가능
			- 객체의 멤버로 존재하는 것이 아님
			- static 멤버함수는 일반적인 클래스의 멤버변수에 접근할 수 없다.(일반적인 클래스의 멤버변수는 객체를 통해서만 접근가능하기 때문)
		- const static 멤버 : 선언과 동시에 초기화 가능
	
	- mutable : const함수 내에서의 값의 변경을 예외적으로 허용
	
- 상속(Inheritance)의 이해
	- 상속(Inheritance)
		- 기존에 정의해 놓은 클래스의 재활용을 목적으로 만들어진 문법적 요소
		- 컨트롤(control) 클래스 or 핸들러(handler) 클래스 : 기능의 처리를 실제로 담당하는 클래스
		- string :  C++ STL에서 제공하는 클래스로, 말 그대로 string(문자열)을 다루는 클래스
		
	- 클래스 용어 정리
		- 상위 클래스, 기초(base)클래스, 슈퍼(super)클래스, 부모클래스
		- 하위 클래스, 유도(derived)클래스, 서브(sub)클래스, 자식 클래스
		
	- 유도 클래스의 객체 생성과 소멸
		- 객체 생성 : 유도 클래스의 객체 생성 과정에서 기초 클래스의 생성자는 100% 호출됨. 기초 클래스의 생성자가 먼저 실행되고 난 다음에 유도 클래스의 생성자가 실행된다.
		- 객체 소멸 : 유도 클래스의 객체가 소멸될 때에는, 유도 클래스의 소멸자가 실행되고 난 다음에 기초 클래스의 소멸자가 실행된다.
			
	- 접근 제어의 형태
		- private : 클래스의 외부에서는 접근이 불가능. 클래스 내부에서만 접근이 가능
		- public : 클래스 외부에서도 접근이 가능
		- protected : : 클래스의 외부에서는 접근이 불가능. 클래스 내부 및 상속하는 유도클래스에서 접근이 가능
		
	- 상속의 형태
		- protected 상속 : protected보다 접근 범위가 넓은 멤버는 protected로 변경시켜서 상속(public 멤버들을 protected로 변경, private 멤버는 그대로 유지)
		- private 상속 : private 보다 접근 범위가 넓은 멤버는  private로 변경시켜서 상속(public, protected 멤버들을 private로 변경)
		- public 상속 : public보다 접근 범위가 넓은 멤버는 public을 변경시켜서 상속 -> private을 제외한 나머지를 그대로 상속 ( 대부분의 상속 )
		
	- 상속을 위한 조건
		- IS-A 관계 성립
		- HAS-A 관계
-----
## 9일차(24.03.04)
- 상속과 다형성
	- 객체 포인터와 참조 관계
		- 객체 포인터 변수 : 객체의 주소 값을 저장하는 포인터 변수가
			- Person* ptr; : 스택 영역에 Person 타입의 객체 포인터 선언
			- ptr = new Person(); : heap영역에 Person 타입의 객체를 생성하고 이를 객체 포인터와 연결 -> 서로 다른 메모리 영역의 값들을 연결(스택과 힙을 연결)하기 위해 포인터를  사용(★)
			- Person형 포인터는 Person 형 포인터 객체뿐만 아니라, Person을 상속하는 유도 클래스의 객체도 가리킬 수 있음
			- 부모 클래스의 객체 포인터는 자식 클래스의 객체도 가리킬 수 있음 (★중요★)
			- 부모 클래스의 객체 포인터는 자식 클래스의 자식 클래스 객체도 가리킬 수 있음
			- 자식 타입의 객체 포인터로 부모 타입 객체를 가리킬 수 없음
			- 접근은 객체 포인터의 타입을 따름(하위 클래스에 오버라이딩 된 함수가 있어도 객체 포인터의 타입을 따른다)
			- C++ 컴파일러는 포인터 연산의 가능성 여부를 판단 할 때, 포인터의 자료형을 기준으로 판단하지, 실제 가리키는 객체의 자료형을 기준으로 판단하지 않음
			
	- 가상 함수(Virtual Function)
		- 객체 중심으로 객체 포인터를 사용하기 위해 사용하는 함수
		- C++의 개념이 아닌 객체지향의 개념
		- virtual 키워드 선언을 통해서 이루어짐(예제: virtaul void MyFunc(){cout<<"FirstFunc"<<endl;})
		- 함수가 가상 함수로 선언되면 해당 함수 호출시, 포인터 자료형을 기반으로 호출대상을 결정하지 않고, 포인터 변수가 실제로 가리키는 객체를 참조하여 호출 대상을 결정
		- 동적 바인딩 : 포인터가 가리키는 객체에 따라 호출되는 함수가 달라지는 것 -> 프로그램이 실행될 때 호출해야할 멤버함수를 결정
		- 정적 바인딩 : 포인터의 타입에 따라 호출되는 함수가 달라지는 것 -> 컴파일 타임에 호출될 함수가 결정
		- 오버라이딩 함수 중 최상위 클래스에 있는 함수에 virtual 선언을 해주면 동명의 함수 모두에 적용됨
		- 순수가상함수(Pure Virtual Function) : 함수의 몸체가 정의되지 않는 가상함수(실행부가 없는 가상함수)
		- 예제 : virtual void ShowSalaryInfo() const = 0;  -> 여기서 '=0'은 0의 대입을 의미하는게 아니고 '명시적으로 몸체를 정의하지 않음'을 컴파일러에게 알리는 것을 의미
		- 순수가상함수를 가지고 있는 클래스는 클래스 객체를 생성할 수 없음(★)
		- 추상클래스(Abstract Class) : 순수가상함수를 가지고 있어 객체를 생성할 수 없는 클래스 -> 미래를 생각하고 만들어지는 클래스
		- 다형성(polymorphism) : 문장은 같은데 결과는 다르게 나오는 형태
		
	- 가상 소멸자와 참조자의 참조 가능성
		- 가상소멸자(Virtual Destructor)
			- 가상소멸자를 하지 않을 경우, 부모클래스의 소멸자만 호출됨 -> 객체 포인터 타입이 중시되기 때문
			- 가상소멸자를 적용 한 경우, 자식 클래스의 소멸자가 먼저 호출되고 부모 클래스의 소멸자가 호출됨
			
		- 참조가능성
			- 특정 클래스 타입의 참조를 이용하면 그 특정 클래스에 정의된 함수가 호출됨
			- void GoodFunction(const First &ref){...} -> First 객체 또는 First를 직접 혹은 간접적으로 상속하는 클래스의 객체가 인자의 대상이 됨
-----
## 10일차(24.03.05)
- 연산자 오버로딩1
	- 연산자 오버로딩의 이해와 유형
		- 개발자가 만든 자료형에 사칙연산기능을 추가하기 위해 사용 ( 개발자가 만든 자료형에는 기본적으로 사칙연산 기능들이 없다 )
		- 연산자 오버로딩의 형식 : 'operator'+ '연산자'
		- 연산자 오버로딩의 유형
			- 멤버함수에 의한 연산자 오버로딩 : pos1.operator+(pos2)
			- 전역함수에 의한 연산자 오버로딩 : operator-(pos1, pos2)
			
		- 오버로딩이 불가능한 연산자의 종류
			- .   			멤버접근 연산자
			- .*  			멤버 포인터 연산자
			- ::  			범위 지정 연산자
			- ?:  			조건 연산자(3항 연산자)
			- sizeof  		바이트 단위 크기 계산
			- typeid		RTTI 관련 연산자
			- static_cast	형 변환 연산자
			
	- 단항 연산자의 오버로딩
		- 대표적인 단항 연산자 : ++, --
		- 전위 증가와 후위 증가의 구분방법:int의 여부
			- ++pos -> pos.operator++();
			- pos++ -> pos.operator++(int)
		
	- 교환법칙 문제의 해결
		- 연산자 오버로딩을 이용하면 서로 다른 자료형의 두 데이터간의 연산을 가능하게 한다

- 연산자 오버로딩2
	- 대입 연산자의 오버로딩
		- 복사생성자와 대입연산자의 특징이 매우 유사하다
		- 두 객체가 이미 생성 및 초기화가 진행된 객체일 경우, 대입 연산자가 호출된다. 
-----
## 11일차(24.03.06)
- 연산자 오버로딩2
	- 대입 연산자의 오버로딩
		- 디폴트 대입 연산자
			- 디폴트 대입 연산자를 쓸 경우, 디폴트 복사생성자처럼 얕은 복사가 실행됨.
			- 대입 연산자의 오버로딩을 
		
		- 상속 구조에서의 대입 연산자 호출
			- 자식 클래스의 대입연산자 정의에서 명시적으로 부모 클래스의 대입 연산자 호출문을 삽입하지 않으면 부모 클래스의 대입 연산자는 호출되지 않음
			- 이때 부모 클래스의 멤버 변수는 멤버 대 멤버의 복사 대상에서 제외됨.
			
	- 배열의 인덱스 연산자 오버로딩
		- 멤버함수 기반으로만 오버로딩해야함
		- 배열 선언부에서 배열 인덱스에 있는 숫자는 방의 크기(예시:int ary[3])
		- 코드 실행에서 배열 인덱스에 있는 숫자는 방의 번호(예시:ary[2])
		- 배열 이름은 배열의 시작 주소이다.(예시:int ary[3]에서 ary는 배열의 시작 주소)
		- ary[0] = 10; 과 *(ary + 0)=10 //*(배열의 시작주소+0)=10은 같은 의미이다.
	
	- 그 이외의 연산자 오버로딩
		- new 연산자 오버로딩
		- 포인터 연산자 오버로딩
		- 스마트 포인터(Smart Pointer)
			- 포인터 역할을 하는 객체
			- 구해야 할 대상이 아닌, 구현해야 할 대상
		
		- 함수객체(펑터, Functor)
			- 함수처럼 호출 가능한 클래스 객체(operator()() 연산자 재정의로 가능)
			- 함수 또는 객체의 동작방식에 유연함을 제공할 때 주로 사용
-----
## 12일차(24.03.07)
- 연산자 오버로딩2
	- 그 이외의 연산자 오버로딩
		- 임시 객체로의 자동 형 변환과 형 변환 연산자
		
- String 클래스의 디자인
	- C++의 표준과 표준 string 클래스
		- string 클래스 : 문자열의 처리를 목적으로 정의된 클래스
		- C style 문자열 : 배열을 사용
		- C++ Style 문자열 : string 클래스를 사용

- 템플릿(Template)
	- 템플릿에 대한 이해와 함수 템플릿
		- 템플릿 : 모형자라는 의미가 담겨있음
		- 함수 템플릿(function template) : 함수를 만들어내는 도구 -> 다양한 자료형의 함수를 만들어 낼 수 있음
		- 템플릿 함수(template function) : 템플릿을 기반으로 컴파일러가 만들어낸 실질적인 함수
		- 자료형이 고정적이지 않아 대표자료형을 사용
		- 둘 이상의 자료형에 대해서도 템플릿 선언 가능
		```C++
		template <typename T>	// T 라는 이름을 이용해서 아래의 함수를 템플릿으로 정의한다는 의미. typename 키워드 대신 class 키워드를 사용해도 됨
		T Add(T num1, T num2)	// T : 대표 자료형
		{
			return num1+num2;	// 템플릿으로 만들어진 함수의 출력
		}
		
		cout << Add<int>(15,20) << endl;	// 35
		cout << Add<double>(2.9, 3.7) << endl;	//6.6

		cout << Add(15, 20) << endl;		// 자료형을 쓰지 않더라도 컴파일 단계에서 입력값의 자료형을 토대로 자료형을 자동으로 결정
		cout << Add(2.9, 3.7) << endl;

		```
		- 함수 템플릿의 특수화(Specialization)
		