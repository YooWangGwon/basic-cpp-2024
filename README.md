# 심화 프로그래밍 2024
부경대학교 2024 IoT 개발자 과정 심화 프로그래밍 언어 학습 리포지토리

## 1일차
- 개발환경 설치
	- Visual Studio 2022 Community 설치
	- C, C++ 소스코드 실행
-----
## 2일차(2024.02.21)
- C++ 기초
	- 기본개념
		- 함수 정의 : 사용할 함수를 정의하는 것
		- 함수 호출 : 함수정의에서 정의한 함수를 사용하기 위해 호출하는 것
		- 변수 선언 : RAM으로부터 저장 할 수 있는 공간을 할당받는 것
		- 전역 변수 : 프로그램의 시작과 동시에 메모리를 할당받음, 선언되어진 범위 안에서만 사용이 가능(static 영역에 저장)
		- 지역 변수 : 변수가 소속된 함수가 시작되어야만 메모리를 할당받음, func함수에서만 사용 가능, 프로그램 영역 어디에서든지 사용가능
		
	- 제어문(control flow statements) : 프로그램의 흐름을 제어하는 경우에 사용하는 실행문
		- 선택 제어문 : if, switch
		- 반복 제어문 : for, while
		
	- 자료형
		- 문자 : 문자, 문자열
		- 숫자 : 정수(int), 실수(float)
	
	- 오버로딩과 오버라이딩
		- 오버로딩(Overloading) : 함수의 이름이 같고, 매개변수의 개수나 타입이 달리하여 다른 함수를 사용하는 것
		- 오버라이딩(OverRiding) : 상속관계에서 발생, 상위 클래스의 함수를 하위 클래스에서 재정의하는 것
-----			
## 3일차
- C++ 기초
	- class 안에 들어 가는 함수 = Method

	- Default Value
	- Reference 함수
		- 반환형 Reference Type
	- Name Space		
	- 전역,지역변수
	- C에서 메모리
		- 스택 : 지역변수, 매개변수
		- HEAP : 사용자에게 할당된 영역
			= Malloc() -> free()반환 = 사용을 할려면 Malloc으로 할당을 받는다
		- data: 함수, 전역변수, 상수, 문자 리터럴
			
	- // A & B = 비트 And 연산자
	- // A && B = 논리 And 연산자 = 논리 곱
-----	
## 4일차(2024.02.23)

- C에서 메모리
	- 스택 : 지역변수 , 매개변수
	- heap : 사용자에게 할당된 영역, 사용하려면 malloc()(C++:new)으로 할당을 받는다. free()(C++:delete)로 반환
	- data : 함수, 전역변수, 상수, 문자리터럴
	
- 헤더파일 : C에 있는 헤더파일을 가져오려면 기존 헤더명에 c를 붙이고 확장자는 생략
	- stdio.h -> cstudio
	- stdlib.h -> cstdlib
	- math.h -> cmath
	
- 구조체(Struct) : 하나 이상의 변수를 묶어서 새로운 자료형을 정의하는 도구, 개발자가 만든 사용자 정의 자료형
	- C 타입 구조체 : 멤버 변수만 보유
	- C++ 타입 구조체 : 멤버 변수와 멤버 함수를 보유
	
- 클래스(Class)
	- 멤버 변수와 멤버 함수로 구성됨
	- 클래스 내부에는 멤버들의 선언으로 작성
	- 멤버함수의 정의를 외부로 빼서 사용할 수 있음(스코프연산자 사용, JAVA에선 불가능)
	- 접근제어 지시자
		- public : 어디서든 접근허용(주로 멤버함수(속성값))
		- protected : 상속관계에 놓여있을 때. 유도 클래스에서의 접근허용
		- private : 클래스 내(클래스 내에 정의도니 함수) 에서만 접근허용(주로 멤버변수)
-----
## 5일차(2024.02.26)
- 클래스(Class)
	- 정보은닉(Information Hiding)
		- 멤버변수를 private으로 선언하고, 해당 변수에 접근하는 함수를 별도로 정의해서, 안전한 형태로 멤버변수의 접근을 유도하는 것 -> 좋은 클래스가 되기 위한 기본조건!!
		- 엑세스 함수(access function) : private으로 선언된 멤버변수를 클래스 외부에서 접근하기 위해 정의되는 함수

	- const
		- 변수를 상수화 시키는 키워드
		- 함수 뒤에 const 선언이 추가되어 있을 경우, 이 함수 내에서는 멤버변수에 저장된 값을 변경하지 않겠다는 뜻 -> 멤버변수의 값을 변경하는 코드가 삽입되면 컴파일 에러가 발생
		- 함수 앞에 const 선언이 추가되어 있을 경우, 함수의 출력값을 상수화

	- 캡슐화(Encapsulation)
		- 클래스 안에 서로 연관있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하는 것

	- 생성자(Constructor)
		- 객체의 생성과 동시에 자동으로 호출되는 멤버 함수로 멤버변수들의 초기화를 담당
		- SimpleCalss sc(20) -> SimpleClass라는 Class의 생성자를 호출하는 함수, 20의 값을 넣고 객체명은 sc가 된다.
		- 클래스의 이름과 함수의 이름이 동일함
		- 반환형이 선언되어 있지 않으며, 실제로 반환하지 않음
		- 객체 생성시 딱 한번 호출됨
		- new 연산자를 이용한 객체 생성에도 생성자가 호출됨(malloc함수로는 생성자가 호출되지 않음)
		- 오버로딩이 가능함
		
	- 디폴트 생성자(Default Constructor) 
		- 매개변수(입력)를 가지지 않는 생성자
		- 모든 클래스는 디폴트 생성자를 가지고 있다
		- 별도의 생성자를 명시적으로 구현하지 않을 경우 default 생성자가 자동으로 만들어짐
		- 별도의 생성자를 명시적으로 구현해 놓은 경우 매개변수가 없는 default 생성자는 만들어지지 않음(필요한 경우 따로 구현해야함)

	- 멤버 이니셜라이저(Member Initializer)
		- 객체 생성시 초기화되지 않는 멤버들을 객체가 생성되기 전에(생성자가 실행되기 전에, 중괄호의 내용이 실행되기 전에) 초기화 할 때 사용(C++에만 존재)
		- 객체 생성 전에 선언과 동시에 초기화가 필요한 경우에 사용가능
		- const형태의 변수선언과 참조형태의 변수 선언에서의 초기화에 사용
		- 객체 생성과 상관없이 미리 초기화가 되는 멤버들을 초기화
		- 파일 분할을 할 경우, 함수의 정의 부분에 입력
		- 예시 : ID(sID), human(ahuman), age(hage)
-----
## 6일차(2024.02.27)
- 클래스(Class)
	- Private 생성자
		- private 생성자는 싱글톤 패턴의 구현 시 사용
		- 외부에서 직접적으로 사용 불가능
		
	- 소멸자(Destructor)
		- 클래스 이름 앞에 '~' 가 붙은 형태
		- 반환형이 선언되어 있지 않으며, 실제로 반환하지 않음
		- 매개변수는 void형으로 선언되어야 하기 떄문에 오버로딩도, 디폴트 값 설정도 불가능
		
	- 포인터(Pointer)
		- 객체 포인터 배열 : 객체의 주소 값 저장이 가능한 포인터 변수로 이뤄진 배열
		- this 포인터
			- 객체 자기자신을 가리키는 용도로 사용하는 포인터 -> 객체 자기자신의 주소값
			- 멤버 이니셜라이저에서는 this 포인터를 사용할 수 없음
			- this:객체 자기자신의 주소값, *this:객체 자기자신, return this: 객체 자기자신을 리턴
		- 애로우 연산자(Arrow Operator) : 객체가 포인터일 때 그 멤버에 접근할 때 사용하는 연산자(예시: ptr1->ShowSimpleData(), this->num1)
		
- 복사 생성자(Copy Constructor)
	- 객체를 복사할 때 호출되는 생성자
	- 객체간 멤버 대 멤버 복사가 발생
	- 생성자의 오버로딩
	- 복사할 객체를 입력으로 가져야하는데 이때 원본 객체의 참조를 입력으로 받아야함 -> 객체 선언형태로 받을 경우, 호출과 매개변수 입력 과정에서 복사생성자가 무한반복됨
	- 디폴트 복사 생성자 : 복사생성자를 명시적으로 구현하지 않아도 자동으로 호출되는 복사 생성자
-----
## 7일차(2024.02.28)
- 복사 생성자(Copy Constructor)
	- 얕은 복사 
		- 디폴트 복사 생성자 사용시 발생.
		- 멤버 대 멤버의 단순 복사를 진행 -> 하나의 문자열을 두 개의 객체가 동시에 참조
		
	- 깊은 복사
		- 멤버 뿐만 아니라 포인터로 참조하는 대상까지도 깊게 복사한다는 뜻
		- 객체 별로 각각 문자열을 참조, 복사 대상이었던 기존 객체가 소멸하더라도 남아있는 객체가 참조하는 문자열이 그대로 남아있음
		
	- 복사 생성저가 호출되는 경우
		- 기존에 생성된 객체를 이용해서 새로운 객체를 초기화하는 경우
		- Call-by-value 방식의 함수호출 과정에서 객체를 인자로 전달하는 경우(Call-by-value : 함수가 인수로 전달받은 값을 복사하여 처리하는 방식)
		- 객체를 반환하되, 참조형으로 반환하지 않는 경우
		
	- 임시객체 :  실행 도중에 잠깐만 사용되는 객체로, 소스 코드에도 없는 힙 이외의 공간에 생성되는 것
		- 일반적으로 임시객체는 참조가 불가능하지만 const 키워드를 붙여서 상수화시키면(메모리에 할당됨) 참조가 가능해짐(예시 : Const Temporary & ref = Temporary(300);)
		- lvalue(좌변값)이 될 수 없음
		- 임시객체는 다음 행으로 넘어가면, 바로 소멸됨. 그러나 참조자에 참조되는 임시객체는, 바로 소멸되지 않음.
		
- friend와 static 그리고 const
	- const 선언
		- 객체의 const선언은 해당 객체의 데이터 변경을 허용하지 않겠다는 의미
		- const객체에서는 멤버 변수에 저장된 값을 수정하지 않는 const 함수만 호출 가능
		- const객체에서는 데이터를 변경하지 않는 함수라 할지라도 const 함수가 아니라면 호출 불가능
		- const 키워드에 따라서 함수 오버로드도 가능
		
	- friend 선언
		- 다른 클래스가 자신의 private 멤버에 직접 접근하는 것을 허용하는 선언
		- friend선언은 클래스 내에 public이나 private 상관없이 어디든 위치가능
	
	- static(정적변수)
		- 지역변수와 전역변수의 특징을 가지고 있음
		- 사용과 접근은 지역변수처럼 선언되어져있는 영역에서만 가능하지만, 할당받은 메모리 영역은 전역변수처럼 한번의 초기화 이후 프로그램의 수명 내내 지속된다.
-----
## 8일차

-----
## 9일차

-----
## 10일차

