# 심화 프로그래밍 2024
부경대학교 2024 IoT 개발자 과정 심화 프로그래밍 언어 학습 리포지토리

## 1일차
- 개발환경 설치
	- Visual Studio 2022 Community 설치
	- C, C++ 소스코드 실행
-----
## 2일차(2024.02.21)
- C++ 기초
	- 기본개념
		- 함수 정의 : 사용할 함수를 정의하는 것
		- 함수 호출 : 함수정의에서 정의한 함수를 사용하기 위해 호출하는 것
		- 변수 선언 : RAM으로부터 저장 할 수 있는 공간을 할당받는 것
		- 전역 변수 : 프로그램의 시작과 동시에 메모리를 할당받음, 선언되어진 범위 안에서만 사용이 가능(static 영역에 저장)
		- 지역 변수 : 변수가 소속된 함수가 시작되어야만 메모리를 할당받음, func함수에서만 사용 가능, 프로그램 영역 어디에서든지 사용가능
		
	- 제어문(control flow statements) : 프로그램의 흐름을 제어하는 경우에 사용하는 실행문
		- 선택 제어문 : if, switch
		- 반복 제어문 : for, while
		
	- 자료형
		- 문자 : 문자, 문자열
		- 숫자 : 정수(int), 실수(float)
	
	- 오버로딩과 오버라이딩
		- 오버로딩(Overloading) : 함수의 이름이 같고, 매개변수의 개수나 타입이 달리하여 다른 함수를 사용하는 것
		- 오버라이딩(OverRiding) : 상속관계에서 발생, 상위 클래스의 함수를 하위 클래스에서 재정의하는 것
-----			
## 3일차
- C++ 기초
	- class 안에 들어 가는 함수 = Method

	- Default Value
	- Reference 함수
		- 반환형 Reference Type
	- Name Space		
	- 전역,지역변수
	- C에서 메모리
		- 스택 : 지역변수, 매개변수
		- HEAP : 사용자에게 할당된 영역
			= Malloc() -> free()반환 = 사용을 할려면 Malloc으로 할당을 받는다
		- data: 함수, 전역변수, 상수, 문자 리터럴
			
	- // A & B = 비트 And 연산자
	- // A && B = 논리 And 연산자 = 논리 곱
-----	
## 4일차(2024.02.23)

- C에서 메모리
	- 스택 : 지역변수 , 매개변수
	- heap : 사용자에게 할당된 영역, 사용하려면 malloc()(C++:new)으로 할당을 받는다. free()(C++:delete)로 반환
	- data : 함수, 전역변수, 상수, 문자리터럴
	
- 헤더파일 : C에 있는 헤더파일을 가져오려면 기존 헤더명에 c를 붙이고 확장자는 생략
	- stdio.h -> cstudio
	- stdlib.h -> cstdlib
	- math.h -> cmath
	
- 구조체(Struct) : 하나 이상의 변수를 묶어서 새로운 자료형을 정의하는 도구, 개발자가 만든 사용자 정의 자료형
	- C 타입 구조체 : 멤버 변수만 보유
	- C++ 타입 구조체 : 멤버 변수와 멤버 함수를 보유
	
- 클래스(Class)
	- 멤버 변수와 멤버 함수로 구성됨
	- 클래스 내부에는 멤버들의 선언으로 작성
	- 멤버함수의 정의를 외부로 빼서 사용할 수 있음(스코프연산자 사용, JAVA에선 불가능)
	- 접근제어 지시자
		- public : 어디서든 접근허용(주로 멤버함수(속성값))
		- protected : 상속관계에 놓여있을 때. 유도 클래스에서의 접근허용
		- private : 클래스 내(클래스 내에 정의도니 함수) 에서만 접근허용(주로 멤버변수)
-----
## 5일차(2024.02.26)
- 클래스(Class)
	- 정보은닉(Information Hiding)
		- 멤버변수를 private으로 선언하고, 해당 변수에 접근하는 함수를 별도로 정의해서, 안전한 형태로 멤버변수의 접근을 유도하는 것 -> 좋은 클래스가 되기 위한 기본조건!!
		- 엑세스 함수(access function) : private으로 선언된 멤버변수를 클래스 외부에서 접근하기 위해 정의되는 함수

	- const
		- 변수를 상수화 시키는 키워드
		- 함수 뒤에 const 선언이 추가되어 있을 경우, 이 함수 내에서는 멤버변수에 저장된 값을 변경하지 않겠다는 뜻 -> 멤버변수의 값을 변경하는 코드가 삽입되면 컴파일 에러가 발생
		- 함수 앞에 const 선언이 추가되어 있을 경우, 함수의 출력값을 상수화

	- 캡슐화(Encapsulation)
		- 클래스 안에 서로 연관있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하는 것

	- 생성자(Constructor)
		- 객체의 생성과 동시에 자동으로 호출되는 멤버 함수로 멤버변수들의 초기화를 담당
		- SimpleCalss sc(20) -> SimpleClass라는 Class의 생성자를 호출하는 함수, 20의 값을 넣고 객체명은 sc가 된다.
		- 클래스의 이름과 함수의 이름이 동일함
		- 반환형이 선언되어 있지 않으며, 실제로 반환하지 않음
		- 객체 생성시 딱 한번 호출됨
		- new 연산자를 이용한 객체 생성에도 생성자가 호출됨(malloc함수로는 생성자가 호출되지 않음)
		
	- 디폴트 생성자(Default Constructor) 
		- 매개변수(입력)를 가지지 않는 생성자
		- 모든 클래스는 디폴트 생성자를 가지고 있다
		- 별도의 생성자를 명시적으로 구현하지 않을 경우 default 생성자가 자동으로 만들어짐
		- 별도의 생성자를 명시적으로 구현해 놓은 경우 매개변수가 없는 default 생성자는 만들어지지 않음(필요한 경우 따로 구현해야함)

	- 멤버 이니셜라이저(Member Initializer)
		- 객체 생성시 초기화되지 않는 멤버들을 객체가 생성되기 전에(생성자가 실행되기 전에) 초기화 할 때 사용(C++에만 존재)
		- 객체 생성 전에 선언과 동시에 초기화가 필요한 경우에 사용가능
		- const 변수와 참조변수의 초기화에 사용
		- 객체 생성과 상관없이 미리 초기화가 되는 멤버들을 초기화
		- 파일 분할을 할 경우, 함수의 정의 부분에 입력
		- 예시 : ID(sID), human(ahuman), age(hage)
-----
## 6일차(2024.02.27)
- 클래스(Class)
	- Private 생성자
		- private 생성자는 싱글톤 패턴의 구현 시 사용
		- 외부에서 직접적으로 사용 불가능
		
	- 소멸자(Destructor)
		- 클래스 이름 앞에 '~' 가 붙은 형태
		- 반환형이 선언되어 있지 않으며, 실제로 반환하지 않음
		- 매개변수는 void형으로 선언되어야 하기 떄문에 오버로딩도, 디폴트 값 설정도 불가능
		
	- 포인터(Pointer)
		- 객체 포인터 배열 : 객체의 주소 값 저장이 가능한 포인터 변수로 이뤄진 배열
		- this 포인터
			- 객체 자기자신을 가리키는 용도로 사용하는 포인터 -> 객체 자기자신의 주소값
			- 멤버 이니셜라이저에서는 this 포인터를 사용할 수 없음
			- this:객체 자기자신의 주소값, *this:객체 자기자신, return this: 객체 자기자신을 리턴
		- 애로우 연산자(Arrow Operator) : 객체가 포인터일 때 그 멤버에 접근할 때 사용하는 연산자(예시: ptr1->ShowSimpleData(), this->num1)
		
- 복사 생성자
	- 객체를 복사할 때 호출되는 생성자
	- 객체간 멤버 대 멤버 복사가 발생
	- 복사할 객체를 입력으로 가져야하는데 이때 원본 객체의 참조를 입력으로 받아야함 -> 객체 선언형태로 받을 경우, 복사생성자가 무한반복됨
	- 디폴트 복사 생성자 : 명시적으로 구현하지 않아도 자동으로 호출되는 복사 생성자
-----
## 7일차

-----
## 8일차

-----
## 9일차

-----
## 10일차

